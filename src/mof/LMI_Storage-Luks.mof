[ Version("0.7.0"), Experimental ]
class LMI_EncryptionElementSettingData : CIM_ElementSettingData
{
};

[ Version("0.7.0"), Experimental, Abstract,
  Description("Base class for all encryption extents. These extents represent "
    "block devices with clear-text data of some encrypted block device.")]
class LMI_EncryptionExtent : LMI_StorageExtent
{

};

[ Version("0.7.0"), Experimental, Abstract,
  Description("Base class for all encryption formats. This format represents "
    "encrypted data on a block device.")]
class LMI_EncryptionFormat : LMI_DataFormat
{
};

[ Version("0.7.0"), Experimental, Abstract, Description("Base class for all encryption settings.")]
class LMI_EncryptionFormatSetting : CIM_SettingData
{
};

[ Version("0.7.0"), Experimental, Abstract, Description("Base class for all encryption capabilities.")]
class LMI_EncryptionFormatCapabilities : CIM_Capabilities
{
};

[ Version("0.7.0"), Experimental ]
class LMI_EncryptionElementCapabilities : CIM_ElementCapabilities
{
};

[ Version("0.7.0"), Experimental, Description("Service which configures LUKS formats on block devices.")]
class LMI_ExtentEncryptionConfigurationService : CIM_Service
{
    [ Implemented(true),
      Description (
        "Formats a device to become a LUKS device. All previous data on the "
        "device is destroyed." ),
      ValueMap { "0", "1", "2", "3", "4", "5", "6", "..", "4096",
                 "4098..32767", "32768..65535" },
      Values { "Job Completed with No Error", "Not Supported",
               "Unknown", "Timeout", "Failed", "Invalid Parameter",
               "In Use", "DMTF Reserved",
               "Method Parameters Checked - Job Started",
               "Method Reserved", "Vendor Specific" } ]
    uint32 CreateEncryptionFormat(
        [ IN, Description("The block device to format.")]
        CIM_StorageExtent REF InExtent,
        [ IN, Description("Parameteres of the LUKS format. This parameter is unused currently and must be NULL.") ]
        LMI_EncryptionFormatSetting REF Goal,
        [ IN, Description("Passphrase to use to encrypt the device. This is not the encryption key!") ]
        string Passphrase,
        [ OUT, IN(false), Description("Reference to the created job.")]
        CIM_ConcreteJob REF Job,
        [ OUT, IN(false), Description("Created format.")]
        LMI_EncryptionFormat REF Format
    );

    [ Implemented(true),
      Description (
        "Opens a LUKS device. This means new block device with clear-text data "
        "is created. This new device is represented by LMI_LUKSStorageDevice "
        "and is returned as 'Extent' output parameter." ),
      ValueMap { "0", "1", "2", "3", "4", "5", "6", "..", "4096",
                 "4098..32767", "32768..65535" },
      Values { "Job Completed with No Error", "Not Supported",
               "Unknown", "Timeout", "Failed", "Invalid Parameter",
               "In Use", "DMTF Reserved",
               "Method Parameters Checked - Job Started",
               "Method Reserved", "Vendor Specific" } ]
    uint32 OpenEncryptionFormat(
        [ IN, Description("Format to open.") ]
        LMI_EncryptionFormat REF Format,
        [ IN, Description("Desired ElementName of the newly created "
            "LMI_LUKSStorageDevice. This name is also used as device mapper "
            "name, i.e. device with path /dev/mapper/<ElementName> will be "
            "created.")]
        string ElementName,
        [ IN, Description("Passphrase to unencrypt the device.") ]
        string Passphrase,
        [ OUT, IN(false), Description("Reference to the created job.")]
        CIM_ConcreteJob REF Job,
        [ OUT, IN(false), Description("Created CIM_StorageExtent which "
            "represents the clear-text block device.")]
        CIM_StorageExtent REF Extent
    );

    [ Implemented(true),
      Description (
        "Closes a LUKS device. Appropriate device mapper device with "
        "clear-text data is destroyed and appropriate LMI_LUKSStorageExtent is "
        "removed." ),
      ValueMap { "0", "1", "2", "3", "4", "5", "6", "..", "4096",
                 "4098..32767", "32768..65535" },
      Values { "Job Completed with No Error", "Not Supported",
               "Unknown", "Timeout", "Failed", "Invalid Parameter",
               "In Use", "DMTF Reserved",
               "Method Parameters Checked - Job Started",
               "Method Reserved", "Vendor Specific" } ]
    uint32 CloseEncryptionFormat (
        [ OUT, IN(false), Description("Reference to the created job.")]
        CIM_ConcreteJob REF Job,
        [ IN, Description("LUKS format to close.")]
        LMI_EncryptionFormat REF Format
    );

    [ Implemented(true),
      Description (
        "Add new passphrase to LUKS format. LUKS supports up to 8 independent "
        "passphrases, adding any additional one will result in error. "
        "Application cannot specify which key slot will be used by which "
        "passphrase.")]
    uint32 AddPassphrase(
        [ IN, Description("The format to add the passphrase to.")]
        LMI_EncryptionFormat REF Format,
        [ IN, Description("Any of the existing passphrase to unlock the format.")]
        string Passphrase,
        [ IN, Description("New passphrase to add.")]
        string NewPassphrase
    );

    [ Implemented(true),
      Description (
        "Remove a passphrase from LUKS format.")]
    uint32 DeletePassphrase(
        [ IN, Description("The format to remove the passphrase from.")]
        LMI_EncryptionFormat REF Format,
        [ IN, Description("The passphrase to remove.")]
        string Passphrase
    );
};

[ Version("0.7.0"), Experimental ]
class LMI_LUKSElementSettingData : LMI_EncryptionElementSettingData
{
};

[ Version("0.7.0"), Experimental,
  Description("This extent represents clear-text block device of some LUKS "
    "format.") ]
class LMI_LUKSStorageExtent : LMI_EncryptionExtent
{
};

[ Version("0.7.0"), Experimental,
  Description("Class representing LUKS data on a block device.")]
class LMI_LUKSFormat : LMI_EncryptionFormat
{
    [Implemented(true), Description("UUID of the LUKS format.")]
    string UUID;

    [ Implemented(true),
      Description("Represents status of each key slot in LUKS header."),
      ValueMap{ "0", "1" },
      Values{ "Free", "Used"} ]
    uint16 SlotStatus[];
};

[ Version("0.7.0"), Experimental,
  Description("Parameters used to create LUKS format by LMI_LUKSConfigurationService. "
    "This class is currently not implemented and may be changed in future "
    "released on OpenLMI.")]
class LMI_LUKSFormatSetting : LMI_EncryptionFormatSetting
{
    [ Description("Encryption block cipher."),
        ValueMap { "0", "1", "2", "65535"},
        Values { "Blowfish", "Serpent", "AES", "Other"}]
    uint16 Cipher;

    [ Description("Name of other encryption block cipher if Cipher property has value of \"Other\".")]
    string OtherCipher;

    [ Description("Block cipher encryption mode."),
        ValueMap { "0", "1", "2" },
        Values { "CBC", "XTS", "Other"}]
    uint16 ChainMode;

    [ Description("Name of other block cipher encryption mode if ChainMode property has value of \"Other\".")]
    string OtherChainMode;

    [ Description("Initialization Vector (IV) used for selected block mode (if block mode requires IV)."),
        ValueMap { "0", "1", "2", "3", "4", "5", "65535" },
        Values { "Plain", "Plain64", "ESSIV", "BENBI", "Null", "LMK", "Other"}]
    uint16 IVMode;

    [ Description("Name of other initialization vector if IVMode property has value of \"Other\".")]
    string OtherIVMode;

    [ Description("Hash algorithm used to derive initial vector. Used only if IVMode has value of \"ESSIV\""),
        ValueMap { "0", "1", "2", "3" },
        Values { "SHA256", "SHA1", "MD5", "Other"}]
    uint16 ESSIVHashAlhorithm;

    [ Description("Name of other hash algorithm to derive initial vector if ESSIVHashAlhorithm has value of \"Other\".")]
    string OtherESSIVHashAlhorithm;

    [ Description("Master key size in bits. The argument has to be a multiple of 8.")]
    uint16 KeySize;
};

[ Version("0.7.0"), Experimental, 
  Description("LMI_LUKSFormatCapabilities specifies combination of property "
    "values, which can be used to create a LUKS format using "
    "LMI_LUKSConfigurationService. "
    "This class is currently not implemented and may be changed in future "
    "released on OpenLMI.")]
class LMI_LUKSFormatCapabilities : LMI_EncryptionFormatCapabilities
{
    [ Description("Array of supported encryption block ciphers."),
        ValueMap { "0", "1", "2", "65535"},
        Values { "Blowfish", "Serpent", "AES", "Other"},
        ArrayType("Indexed")]
    uint16 Ciphers[];

    [ Description("Array of names of supported block ciphers for ciphers which have value \"Other\" in Ciphers property."
        " Not every combination of Cipher and ChainMode is allowed. All possible combinations can be retrieved by GetSupportedChainModes() method."),
        ArrayType("Indexed")]
    string OtherCiphers[];

    [ Description("Array of supported encryption modes."),
        ValueMap{ "0", "1", "2", "3", "4", "5", "65535"},
        Values{ "CTR", "CBC", "ECB", "XTR", "LRW", "PCBC", "Other"},
        ArrayType("Indexed")]
    uint16 ChainModes[];

    [ Description("Array of names of supported encryption modes which have value \"Other\" in ChainModes property."),
        ArrayType("Indexed")]
    string OtherChainModes[];

    [ Description("Array of supported initialization vector modes."),
        ValueMap { "0", "1", "2", "3", "4", "5", "65535" },
        Values { "Plain", "Plain64", "ESSIV", "BENBI", "Null", "LMK", "Other"},
        ArrayType("Indexed")]
    uint16 IVModes[];

    [ Description("Array of supported hash algorithms used to derive initial vector in \"ESSIV\" mode."),
        ValueMap { "0", "1", "2", "3" },
        Values { "SHA256", "SHA1", "MD5", "Other"},
        ArrayType("Indexed")]
    uint16 ESSIVHashAlhorithms[];

    [ Description("Array of names of other hash algorithms to derive initial vector in \"ESSIV\" mode, which have value \"Other\" in ESSIVHashAlhorithms property."),
        ArrayType("Indexed")]
    string OtherESSIVHashAlhorithms[];

    [ Description("Discover all encryption modes which are supported for given block cipher. Minimum and maximum key sizes are also returned.")]
    uint32 GetSupportedChainModes(

        [ Description("Encryption block cipher."),
            ValueMap { "0", "1", "2", "65535"},
            Values { "Blowfish", "Serpent", "AES", "Other"}]
        uint16 Cipher,

        [ Description("Name of other encryption block cipher if Cipher property has value of \"Other\".")]
        string OtherCipher,

        [ OUT, Description("Array of supported encryption modes for given cipher."),
            ValueMap{ "0", "1", "2", "3", "4", "5", "65535"},
            Values{ "CTR", "CBC", "ECB", "XTR", "LRW", "PCBC", "Other"},
            ArrayType("Indexed")]
        uint16 ChainModes[],

        [ OUT, Description("Array of names of supported encryption modes which have value \"Other\" in ChainModes parameter."),
            ArrayType("Indexed")]
        string OtherChainModes[],

        [ OUT, Description("Array of integers specifying the minimum key size in bytes corresponding to given block cipher and entry in ChainModes parameter."),
            ArrayType("Indexed")]
        uint16 KeySizeMin[],
        [ OUT, Description("Array of integers specifying the maximum key size in bytes corresponding to given block cipher and entry in ChainModes parameter."),
            ArrayType("Indexed")]
        uint16 KeySizeMax[]
    );
};


[ Version("0.7.0"), Experimental ]
class LMI_LUKSSettingAssociatedToCapabilities : CIM_SettingAssociatedToCapabilities
{
};

[ Version("0.7.0"), Experimental ]
class LMI_LUKSElementCapabilities : LMI_EncryptionElementCapabilities
{
};

[ Version("0.7.0"), Experimental ]
class LMI_LUKSBasedOn : CIM_BasedOn
{
};