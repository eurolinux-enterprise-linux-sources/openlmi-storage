[ Version("0.7.0"), Experimental, Abstract,
  Description("Base class for all encryption extents. These extents represent "
    "block devices with clear-text data of some encrypted block device.")]
class LMI_EncryptionExtent : LMI_StorageExtent
{

};

[ Version("0.7.0"), Experimental, Abstract,
  Description("Base class for all encryption formats. This format represents "
    "encrypted data on a block device.")]
class LMI_EncryptionFormat : LMI_DataFormat
{
};

[ Version("0.7.0"), Experimental, Description("Service which configures LUKS formats on block devices.")]
class LMI_ExtentEncryptionConfigurationService : CIM_Service
{
    [ Implemented(true),
      Description (
        "Formats a device to become a LUKS device. All previous data on the "
        "device is destroyed." ),
      ValueMap { "0", "1", "2", "3", "4", "5", "6", "..", "4096",
                 "4098..32767", "32768..65535" },
      Values { "Job Completed with No Error", "Not Supported",
               "Unknown", "Timeout", "Failed", "Invalid Parameter",
               "In Use", "DMTF Reserved",
               "Method Parameters Checked - Job Started",
               "Method Reserved", "Vendor Specific" } ]
    uint32 CreateEncryptionFormat(
        [ IN, Description("The block device to format.")]
        CIM_StorageExtent REF InExtent,
        [ IN, Description("Parameteres of the LUKS format. This parameter is unused currently and must be NULL.") ]
        LMI_EncryptionFormatSetting REF Goal,
        [ IN, Description("Passphrase to use to encrypt the device. This is not the encryption key!") ]
        string Passphrase,
        [ OUT, IN(false), Description("Reference to the created job.")]
        CIM_ConcreteJob REF Job,
        [ OUT, IN(false), Description("Created format.")]
        LMI_EncryptionFormat REF Format
    );

    [ Implemented(true),
      Description (
        "Opens a LUKS device. This means new block device with clear-text data "
        "is created. This new device is represented by LMI_LUKSStorageDevice "
        "and is returned as 'Extent' output parameter." ),
      ValueMap { "0", "1", "2", "3", "4", "5", "6", "..", "4096",
                 "4098..32767", "32768..65535" },
      Values { "Job Completed with No Error", "Not Supported",
               "Unknown", "Timeout", "Failed", "Invalid Parameter",
               "In Use", "DMTF Reserved",
               "Method Parameters Checked - Job Started",
               "Method Reserved", "Vendor Specific" } ]
    uint32 OpenEncryptionFormat(
        [ IN, Description("Format to open.") ]
        LMI_EncryptionFormat REF Format,
        [ IN, Description("Desired ElementName of the newly created "
            "LMI_LUKSStorageDevice. This name is also used as device mapper "
            "name, i.e. device with path /dev/mapper/<ElementName> will be "
            "created.")]
        string ElementName,
        [ IN, Description("Passphrase to unencrypt the device.") ]
        string Passphrase,
        [ OUT, IN(false), Description("Reference to the created job.")]
        CIM_ConcreteJob REF Job,
        [ OUT, IN(false), Description("Created CIM_StorageExtent which "
            "represents the clear-text block device.")]
        CIM_StorageExtent REF Extent
    );

    [ Implemented(true),
      Description (
        "Closes a LUKS device. Appropriate device mapper device with "
        "clear-text data is destroyed and appropriate LMI_LUKSStorageExtent is "
        "removed." ),
      ValueMap { "0", "1", "2", "3", "4", "5", "6", "..", "4096",
                 "4098..32767", "32768..65535" },
      Values { "Job Completed with No Error", "Not Supported",
               "Unknown", "Timeout", "Failed", "Invalid Parameter",
               "In Use", "DMTF Reserved",
               "Method Parameters Checked - Job Started",
               "Method Reserved", "Vendor Specific" } ]
    uint32 CloseEncryptionFormat (
        [ OUT, IN(false), Description("Reference to the created job.")]
        CIM_ConcreteJob REF Job,
        [ IN, Description("LUKS format to close.")]
        LMI_EncryptionFormat REF Format
    );

    [ Implemented(true),
      Description (
        "Add new passphrase to LUKS format. LUKS supports up to 8 independent "
        "passphrases, adding any additional one will result in error. "
        "Application cannot specify which key slot will be used by which "
        "passphrase.")]
    uint32 AddPassphrase(
        [ IN, Description("The format to add the passphrase to.")]
        LMI_EncryptionFormat REF Format,
        [ IN, Description("Any of the existing passphrase to unlock the format.")]
        string Passphrase,
        [ IN, Description("New passphrase to add.")]
        string NewPassphrase
    );

    [ Implemented(true),
      Description (
        "Remove a passphrase from LUKS format.")]
    uint32 DeletePassphrase(
        [ IN, Description("The format to remove the passphrase from.")]
        LMI_EncryptionFormat REF Format,
        [ IN, Description("The passphrase to remove.")]
        string Passphrase
    );
};

[ Version("0.7.0"), Experimental,
  Description("This extent represents clear-text block device of some LUKS "
    "format.") ]
class LMI_LUKSStorageExtent : LMI_EncryptionExtent
{
};

[ Version("0.7.0"), Experimental,
  Description("Class representing LUKS data on a block device.")]
class LMI_LUKSFormat : LMI_EncryptionFormat
{
    [Implemented(true), Description("UUID of the LUKS format.")]
    string UUID;

    [ Implemented(true),
      Description("Represents status of each key slot in LUKS header."),
      ValueMap{ "0", "1" },
      Values{ "Free", "Used"} ]
    uint16 SlotStatus[];
};

[ Version("0.7.0"), Experimental ]
class LMI_LUKSBasedOn : CIM_BasedOn
{
};